\declaremodule{extension}{pygsl.ieee}
\moduleauthor{Achim G\"adke}{achimgaedke@users.sourceforge.net}

This chapter lists features to configure the ``Floating Point Unit'' of your machine.
The exact behaviour of your Floating Point Unit can't be discussed here in general --- its just machine type dependent.

\begin{funcdesc} {set_mode}{int precision, int rounding, int exception\_mask}
the mode has effect on the behaviour during calcualtion, e.g. division by zero or rounding.

The following constants are used as precision argument:
\begin{tableii}{l|l}{constant}{mode value}{definition via gsl}
\lineii{single\_precision}{\code{GSL\_IEEE\_SINGLE\_PRECISION}}
\lineii{double\_precision}{\code{GSL\_IEEE\_DOUBLE\_PRECISION}}
\lineii{extended\_precision}{\code{GSL\_IEEE\_EXTENDED\_PRECISION}}
\end{tableii}
Possible round arguments are:
\begin{tableii}{l|l}{constant}{mode value}{definition via gsl}
\lineii{round\_to\_nearest}{\code{GSL\_IEEE\_ROUND\_TO\_NEAREST}}
\lineii{round\_down}{\code{GSL\_IEEE\_ROUND\_DOWN}}
\lineii{round\_up}{\code{GSL\_IEEE\_ROUND\_UP}}
\lineii{round\_to\_zero}{\code{GSL\_IEEE\_ROUND\_TO\_ZERO}}
\end{tableii}
These exception arguments can be added.
\constant{mask\_all} is the sum of all 5 \constant{mask\_*} constants.
\begin{tableii}{l|l}{constant}{mode value}{definition via gsl}
\lineii{mask\_invalid}{\code{GSL\_IEEE\_MASK\_INVALID}}
\lineii{mask\_denormalized}{\code{GSL\_IEEE\_MASK\_DENORMALIZED}}
\lineii{mask\_division\_by\_zero}{\code{GSL\_IEEE\_MASK\_DIVISION\_BY\_ZERO}}
\lineii{mask\_overflow}{\code{GSL\_IEEE\_MASK\_OVERFLOW}}
\lineii{mask\_underflow}{\code{GSL\_IEEE\_MASK\_UNDERFLOW}}
\lineii{mask\_all}{\code{GSL\_IEEE\_MASK\_ALL}}
\lineii{trap\_inexact}{\code{GSL\_IEEE\_TRAP\_INEXACT}}
\end{tableii}
\end{funcdesc}

\begin{funcdesc} {env\_setup}{}
sets the ieee mode from \envvar{GSL\_IEEE\_MODE}. This is not called any more
automatically  when importing the  \module{pygsl}.
\end{funcdesc}

\begin{funcdesc} {bin\_repr}{float value}
%\cfunction{gsl_ieee_double_to_rep}
returns the binary representation as tuple with the following contents:
\code{(int sign, string mantissa, int exponent, int type)}
These values are used as \constant{type} in \function{bin\_repr}:
\begin{tableii}{l|l}{constant}{type value}{definition via gsl}
\lineii{type\_nan}{\code{GSL\_IEEE\_TYPE\_NAN}}
\lineii{type\_inf}{\code{GSL\_IEEE\_TYPE\_INF}}
\lineii{type\_normal}{\code{GSL\_IEEE\_TYPE\_NORMAL}}
\lineii{type\_denormal}{\code{GSL\_IEEE\_TYPE\_DENORMAL}}
\lineii{type\_zero}{\code{GSL\_IEEE\_TYPE\_ZERO}}
\end{tableii}
\end{funcdesc}

\begin{funcdesc}{isnan}{float value}
determines if the argument is not a valid number
\end{funcdesc}

\begin{funcdesc}{nan}{}
generates a ``not-a-number'' value. This is implemented as function, because of the potential exception generation by your floating-point unit.
\end{funcdesc}

\begin{funcdesc}{isinf}{float value}
returns -1 if the argument represents a negative infinite value and +1 if positive, 0 otherwise
\end{funcdesc}

\begin{funcdesc}{posinf}{}
gives you the representation of ``positive infinity''
\end{funcdesc}

\begin{funcdesc}{neginf}{}
the same as posinf, but negative
\end{funcdesc}

\begin{funcdesc}{finite}{float value}
results in 1 if the value is finite, 0 if it is not a number or infinite
\end{funcdesc}

\section{Information for Distributors}
  
The information given here is intended for people distributing pygsl as well
as for people who are not afraid to run code generation tools in case building pygsl
fails. 

\subsection{Preferable array module}
The numpy array module should be the first choice these days.

\subsection{Wrapper generated modules}
The following modules are generated by  SWIG wrappers:
\begin{itemize}
\item 
_block
\item 
_callback
\item 
gslwrap
\item 
hankel
\item 
_poly
\item
bspline
\end{itemize}

In case on of these modules shows a compilation error, just delete the
corresponding file in the swig_src directory (e.g. swig_src/poly_wrap.c if
for the poly module.). Set the variable \code{USE_SWIG} to \code{1} in the 
\file{setup.py} file.
Run the build process again. Now \file{setup.py} should call swig and rebuild the
module wrappers.

\subsection{Dedicated wrappers}
  
Some modules come with their own wrapping tools which are implemented in python.

\subsection{The const module}
Edit the file \file{src/tools/extract_tool.py} and enter manually the version
of the actual gsl version you are building. 
Change into the src directory. Define the shell variable
\code{PYGSL_GSLCVS} variable, so that it either points to the GSL CVS
  repository or to the include directory of your GSL installation (typically
  /usr/include on a linux installation).
  Then type \code{python ../tools/constants_tool.py}
  This will generate the files  
  \file{const_m_array.c}
  \file{const_num_array.c}
  \file{const_cgsm_array.c}
  \file{const_mksa_array.c}
and the files 
  \file{const_cgs_array.c}
  \file{const_mks_array.c}
for the GSL versions which come with these files.

\subsection{The special function module.}
    
  PyGSL comes with two implementations for the special functions. The sf and
  the testing.sf module. The first one was the first implementation and will be removed soon,
  while the
  later one wraps the special functions as \emph{numpy}
  UFuncs. The UFunc module will eventually replace the sf module.

  Generating the wrapper has not been automatized yet. First swig is used to 
  parse the header files and dump them into xml and then a specialized wrapper
  reads this tree and writes the wrappers.

  This involves the following steps:
  \begin{itemize}
  \item 
    Change into the directory \file{testing/tools}
  \item
    Run \code{swig -python -I<gsl header directory> -xml swig_test.i}
    So on a linux machine this is typically	 
    \code{swig -python -I/usr/include -xml swig_test.i}
  \item
    Change into the directory \file{testing/src/sf}
  \item
    Run the wrapper generator using 
    \code{python ../../tools/sf_functions.py}
    
  \item
   Run the build process. Set \code{BUILD_TESTING = 1} in the
   setup.py file. If required update the time stamp of the file 
   \file{testing/src/sf/sfmodule_testing.c}. This will build the module
   \module{_ufuncs}.
  \end{itemize}
  The functions not wrapped automatically are defined in the list
  \code{exclude_list}	in the file \file{sf_functions.py}


<?xml version="1.0" encoding="ISO-8859-15"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-15"/>
    <meta name="generator" content="Emacs"/>
    <meta name="author" content="Pierre Schnizer"/>
    <meta name="version" content="$Id: README-Distributors.html,v 1.1 2007/11/26 18:58:09 schnizer Exp $"/>

    <meta name="keywords" content="numeric, scientific, python,
    extension, module, GNU, library"/>

    <title>PyGSL: Information for distributors</title>

  </head>
  <body>
  <h1>Information for Distributors</h1>
  
  The information given here is intended for people distributing pygsl as well
  as for people who are not afraid to run code generation tools in case pygsl
  generates trouble.

  <h2>Preferable array module</h2>
  The numpy array module should be the first choice these days.

  <h2>Wrapper generated modules</h2>
  The following modules are generated by the SWIG wrappers:
    <ul>    
    <li>_block</li>
    <li>_callback</li>
    <li>gslwrap</li>
    <li>hankel</li>
    <li>_poly</li>
    </ul>
    In case on of these modules shows a compilation error, just delete the
    corresponding file in the swig_src directory (e.g. swig_src/poly_wrap.c if
  for the poly module.). Set the variable <tt>USE_SWIG</tt> to <tt>1</tt> in the 
  <tt>setup.py</tt> file.
    Run the build process again. Now setup.py should call swig and rebuild the
  module wrappers.

  <h2>Dedicated wrappers</h2>
  
  Some modules come with their own wrapping tools which are implemented in python.
  
  <h3>The const module</h3>
  Change into the src directory. Define the shell variable
  <tt>PYGSL_GSLCVS</tt> variable, so that it either points to the GSL CVS
  repository or to the include directory of your GSL installation (typically
  /usr/include on a linux installation).
  Then type <tt>python ../tools/constants_tool.py</tt>
  This will generate the files  
  <tt>const_m_array.c</tt>  
  <tt>const_num_array.c</tt>  
  <tt>const_cgsm_array.c</tt>  
  <tt>const_mksa_array.c</tt>  

  <h3>The special function module</h3>
    
  PyGSL comes with two implementations for the special functions. The sf and
  the testing.sf module. The first one was the first implementation, while the
  later one wraps the special functions as <bf>Numeric</bf> or <bf>numpy</bf>
  UFuncs. The UFunc module will eventually replace the sf module.
  <p>
  Generating the wrapper has not been automatized yet. First swig is used to 
  parse the header files and dump them into xml and then a specialized wrapper
  reads this tree and writes the wrappers.
  <p>
  This involves the following steps:
  <ul>
  <li>Change into the directory <tt>testing/tools</tt></li>
  <li>Run <tt>swig -python -I<gsl header directory> -xml swig_test.i</tt>
   So on a linux machine this is typically	 
   <tt> swig -python -I/usr/include -xml swig_test.i</tt>
   <li>Change into the directory <tt>testing/src/sf</tt>
   <li>Run the wrapper generator using <tt>python ../../tools/sf_functions.py</tt></li>
   <li>Run the build process. Set <tt>BUILD_TESTING = 1</tt> in the
   setup.py file. If required update the time stamp of the file 
   <tt>testing/src/sf/sfmodule_testing.c</tt>. This will build the module
   <tt>_ufuncs</tt>.
  </li>
  </ul>
  The functions not wrapped automatically are defined in the list
  <tt>exclude_list</tt>	in the file <tt>sf_functions.py</tt>.
  </body>
</html>

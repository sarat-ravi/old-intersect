!%f90 -*- f90 -*-
! Signatures for f2py-wrappers of FORTRAN BLAS functions.
!
! Author: Pearu Peterson
! Created: Jan-Feb 2002
! $Revision$ $Date$
!


python module fblas
    interface

!%f90 -*- f90 -*-
! Signatures for f2py-wrappers of FORTRAN LEVEL 1 BLAS functions.
!
! Author: Pearu Peterson
! Created: Jan-Feb 2002
! $Revision$ $Date$
!
! rotg, rotmg, rot, rotm
! swap, scal, copy, axpy
! dot, dotu, dotc
! nrm2, asum, amax, iamax
!
! Not Implemented: NONE
!
! NOTE: Avoiding wrappers hack does not work under 64-bit Gentoo system
! with single precision routines, so they are removed.

! Level 1 BLAS

subroutine srotg(a,b,c,s)
  ! a,b are elements of a direction vector of rotated x-axis.

  ! if abs(a) + abs(b)>0:
  !     roe = abs(a)<abs(b) ? b : a
  !     r = sign(roe) * sqrt(a^2 + b^2)
  !     c = a/r
  !     s = b/r
  ! else:
  !     c = 1
  !     s = r = 0
  ! a = r
  ! if 0 < abs(c) <= s: b = 1/c  ! XXX: what is b when returned
  ! else: b = s 

  callprotoargument float*,float*,float*,float*

  ! XXX: a and b get new values. Are they relevant?
  real intent(in) :: a
  real intent(in) :: b
  real intent(out,out=c) :: c
  real intent(out,out=s) :: s

end subroutine srotg


subroutine drotg(a,b,c,s)
  ! a,b are elements of a direction vector of rotated x-axis.

  ! if abs(a) + abs(b)>0:
  !     roe = abs(a)<abs(b) ? b : a
  !     r = sign(roe) * sqrt(a^2 + b^2)
  !     c = a/r
  !     s = b/r
  ! else:
  !     c = 1
  !     s = r = 0
  ! a = r
  ! if 0 < abs(c) <= s: b = 1/c  ! XXX: what is b when returned
  ! else: b = s 

  callprotoargument double*,double*,double*,double*

  ! XXX: a and b get new values. Are they relevant?
  double precision intent(in) :: a
  double precision intent(in) :: b
  double precision intent(out,out=c) :: c
  double precision intent(out,out=s) :: s

end subroutine drotg


subroutine crotg(a,b,c,s)
  ! a,b are elements of a direction vector of rotated x-axis.

  ! if abs(a) + abs(b)>0:
  !     roe = abs(a)<abs(b) ? b : a
  !     r = sign(roe) * sqrt(a^2 + b^2)
  !     c = a/r
  !     s = b/r
  ! else:
  !     c = 1
  !     s = r = 0
  ! a = r
  ! if 0 < abs(c) <= s: b = 1/c  ! XXX: what is b when returned
  ! else: b = s 

  callprotoargument complex_float*,complex_float*,complex_float*,complex_float*

  ! XXX: a and b get new values. Are they relevant?
  complex intent(in) :: a
  complex intent(in) :: b
  complex intent(out,out=c) :: c
  complex intent(out,out=s) :: s

end subroutine crotg


subroutine zrotg(a,b,c,s)
  ! a,b are elements of a direction vector of rotated x-axis.

  ! if abs(a) + abs(b)>0:
  !     roe = abs(a)<abs(b) ? b : a
  !     r = sign(roe) * sqrt(a^2 + b^2)
  !     c = a/r
  !     s = b/r
  ! else:
  !     c = 1
  !     s = r = 0
  ! a = r
  ! if 0 < abs(c) <= s: b = 1/c  ! XXX: what is b when returned
  ! else: b = s 

  callprotoargument complex_double*,complex_double*,complex_double*,complex_double*

  ! XXX: a and b get new values. Are they relevant?
  double complex intent(in) :: a
  double complex intent(in) :: b
  double complex intent(out,out=c) :: c
  double complex intent(out,out=s) :: s

end subroutine zrotg




! <prefix2=s,d> <ctype2=float,double> <ftype2=real,double precision>
subroutine srotmg(d1,d2,x1,y1,param)
  ! XXX: Could one give a geometrical meaning to the parameters d1,d2,x1,y1?

  ! Construct matrix H such that (H * (sqrt(d1)*x1,sqrt(d2)*y1)^T)_2 = 0.
  ! H = [[1,0],[0,1]] if param[0]==-2
  ! H = [[param[1],param[3]],[param[2],param[4]]] if param[0]==-1
  ! H = [[1,param[3]],[param[2],1]] if param[0]==0
  ! H = [[param[1],1],[-1,param[4]]] if param[0]==1

  callstatement { (*f2py_func)(&d1,&d2,&x1,&y1,param); }
  callprotoargument float*,float*,float*,float*,float*

  real intent(in) :: d1
  real intent(in) :: d2
  real intent(in) :: x1
  real intent(in) :: y1
  real intent(out), dimension(5) :: param
end subroutine srotmg

subroutine drotmg(d1,d2,x1,y1,param)
  ! XXX: Could one give a geometrical meaning to the parameters d1,d2,x1,y1?

  ! Construct matrix H such that (H * (sqrt(d1)*x1,sqrt(d2)*y1)^T)_2 = 0.
  ! H = [[1,0],[0,1]] if param[0]==-2
  ! H = [[param[1],param[3]],[param[2],param[4]]] if param[0]==-1
  ! H = [[1,param[3]],[param[2],1]] if param[0]==0
  ! H = [[param[1],1],[-1,param[4]]] if param[0]==1

  callstatement { (*f2py_func)(&d1,&d2,&x1,&y1,param); }
  callprotoargument double*,double*,double*,double*,double*

  double precision intent(in) :: d1
  double precision intent(in) :: d2
  double precision intent(in) :: x1
  double precision intent(in) :: y1
  double precision intent(out), dimension(5) :: param
end subroutine drotmg




subroutine srot(n,x,offx,incx,y,offy,incy,c,s)

  ! Apply plane rotation

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,&c,&s)
  callprotoargument int*,float*,int*,float*,int*,float*,float*

  real dimension(*),intent(in,out,copy) :: x,y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

  real intent(in) :: c
  real intent(in) :: s
end subroutine srot



subroutine drot(n,x,offx,incx,y,offy,incy,c,s)

  ! Apply plane rotation

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,&c,&s)
  callprotoargument int*,double*,int*,double*,int*,double*,double*

  double precision dimension(*),intent(in,out,copy) :: x,y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

  double precision intent(in) :: c
  double precision intent(in) :: s
end subroutine drot



subroutine csrot(n,x,offx,incx,y,offy,incy,c,s)

  ! Apply plane rotation

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,&c,&s)
  callprotoargument int*,complex_float*,int*,complex_float*,int*,float*,float*

  complex dimension(*),intent(in,out,copy) :: x,y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

  real intent(in) :: c
  real intent(in) :: s
end subroutine csrot



subroutine zdrot(n,x,offx,incx,y,offy,incy,c,s)

  ! Apply plane rotation

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,&c,&s)
  callprotoargument int*,complex_double*,int*,complex_double*,int*,double*,double*

  double complex dimension(*),intent(in,out,copy) :: x,y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

  double precision intent(in) :: c
  double precision intent(in) :: s
end subroutine zdrot




subroutine srotm(n,x,offx,incx,y,offy,incy,param)

  ! Apply modified plane rotation

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,param)
  callprotoargument int*,float*,int*,float*,int*,float*

  real dimension(*),intent(in,out,copy) :: x,y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

  real dimension(5),intent(in) :: param
end subroutine srotm



subroutine drotm(n,x,offx,incx,y,offy,incy,param)

  ! Apply modified plane rotation

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,param)
  callprotoargument int*,double*,int*,double*,int*,double*

  double precision dimension(*),intent(in,out,copy) :: x,y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

  double precision dimension(5),intent(in) :: param
end subroutine drotm




subroutine sswap(n,x,offx,incx,y,offy,incy)

  ! Swap two arrays: x __l1 y

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,float*,int*,float*,int*

  real dimension(*),intent(in,out) :: x,y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine sswap



subroutine dswap(n,x,offx,incx,y,offy,incy)

  ! Swap two arrays: x __l1 y

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,double*,int*,double*,int*

  double precision dimension(*),intent(in,out) :: x,y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine dswap



subroutine cswap(n,x,offx,incx,y,offy,incy)

  ! Swap two arrays: x __l1 y

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,complex_float*,int*,complex_float*,int*

  complex dimension(*),intent(in,out) :: x,y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine cswap



subroutine zswap(n,x,offx,incx,y,offy,incy)

  ! Swap two arrays: x __l1 y

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,complex_double*,int*,complex_double*,int*

  double complex dimension(*),intent(in,out) :: x,y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine zswap



subroutine sscal(n,a,x,offx,incx)

  ! Calculate y = a*x

  real intent(in):: a
  callstatement (*f2py_func)(&n,&a,x+offx,&incx)
  callprotoargument int*,float*,float*,int*

  real dimension(*),intent(in,out) :: x
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end subroutine sscal


subroutine dscal(n,a,x,offx,incx)

  ! Calculate y = a*x

  double precision intent(in):: a
  callstatement (*f2py_func)(&n,&a,x+offx,&incx)
  callprotoargument int*,double*,double*,int*

  double precision dimension(*),intent(in,out) :: x
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end subroutine dscal


subroutine cscal(n,a,x,offx,incx)

  ! Calculate y = a*x

  complex intent(in):: a
  callstatement (*f2py_func)(&n,&a,x+offx,&incx)
  callprotoargument int*,complex_float*,complex_float*,int*

  complex dimension(*),intent(in,out) :: x
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end subroutine cscal


subroutine zscal(n,a,x,offx,incx)

  ! Calculate y = a*x

  double complex intent(in):: a
  callstatement (*f2py_func)(&n,&a,x+offx,&incx)
  callprotoargument int*,complex_double*,complex_double*,int*

  double complex dimension(*),intent(in,out) :: x
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end subroutine zscal




subroutine csscal(n,a,x,offx,incx)

  ! Calculate y = a*x

  real intent(in):: a

  callstatement (*f2py_func)(&n,&a,x+offx,&incx)
  callprotoargument int*,float*,complex_float*,int*

  complex dimension(*),intent(in,out,copy) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end subroutine csscal



subroutine zdscal(n,a,x,offx,incx)

  ! Calculate y = a*x

  double precision intent(in):: a

  callstatement (*f2py_func)(&n,&a,x+offx,&incx)
  callprotoargument int*,double*,complex_double*,int*

  double complex dimension(*),intent(in,out,copy) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end subroutine zdscal




subroutine scopy(n,x,offx,incx,y,offy,incy)

  ! Copy y <- x

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,float*,int*,float*,int*

  real dimension(*),intent(in) :: x
  real dimension(*),intent(in,out) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine scopy



subroutine dcopy(n,x,offx,incx,y,offy,incy)

  ! Copy y <- x

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,double*,int*,double*,int*

  double precision dimension(*),intent(in) :: x
  double precision dimension(*),intent(in,out) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine dcopy



subroutine ccopy(n,x,offx,incx,y,offy,incy)

  ! Copy y <- x

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,complex_float*,int*,complex_float*,int*

  complex dimension(*),intent(in) :: x
  complex dimension(*),intent(in,out) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine ccopy



subroutine zcopy(n,x,offx,incx,y,offy,incy)

  ! Copy y <- x

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,complex_double*,int*,complex_double*,int*

  double complex dimension(*),intent(in) :: x
  double complex dimension(*),intent(in,out) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine zcopy



subroutine saxpy(n,a,x,offx,incx,y,offy,incy)

  ! Calculate z = a*x+y, where a is scalar.

  callstatement (*f2py_func)(&n,&a,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,float*,float*,int*,float*,int*

  real dimension(*),intent(in) :: x
  real dimension(*),intent(in,out,out=z) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

  real optional, intent(in):: a=1.0

end subroutine saxpy


subroutine daxpy(n,a,x,offx,incx,y,offy,incy)

  ! Calculate z = a*x+y, where a is scalar.

  callstatement (*f2py_func)(&n,&a,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,double*,double*,int*,double*,int*

  double precision dimension(*),intent(in) :: x
  double precision dimension(*),intent(in,out,out=z) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

  double precision optional, intent(in):: a=1.0

end subroutine daxpy


subroutine caxpy(n,a,x,offx,incx,y,offy,incy)

  ! Calculate z = a*x+y, where a is scalar.

  callstatement (*f2py_func)(&n,&a,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,complex_float*,complex_float*,int*,complex_float*,int*

  complex dimension(*),intent(in) :: x
  complex dimension(*),intent(in,out,out=z) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

  complex optional, intent(in):: a=(1.0,0.0)

end subroutine caxpy


subroutine zaxpy(n,a,x,offx,incx,y,offy,incy)

  ! Calculate z = a*x+y, where a is scalar.

  callstatement (*f2py_func)(&n,&a,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,complex_double*,complex_double*,int*,complex_double*,int*

  double complex dimension(*),intent(in) :: x
  double complex dimension(*),intent(in,out,out=z) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

  double complex optional, intent(in):: a=(1.0,0.0)

end subroutine zaxpy



function sdot(n,x,offx,incx,y,offy,incy) result (xy)

  real sdot,xy

  callstatement (*f2py_func)(&sdot,&n,x+offx,&incx,y+offy,&incy)
  callprotoargument float*,int*,float*,int*,float*,int*

  real dimension(*),intent(in) :: x
  real dimension(*),intent(in) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end function sdot


function ddot(n,x,offx,incx,y,offy,incy) result (xy)

  double precision ddot,xy

  callstatement (*f2py_func)(&ddot,&n,x+offx,&incx,y+offy,&incy)
  callprotoargument double*,int*,double*,int*,double*,int*

  double precision dimension(*),intent(in) :: x
  double precision dimension(*),intent(in) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end function ddot



! <prefix2c=c,z> <ftype2c=complex,double complex> <ctype2c=complex_float,complex_double>
subroutine cdotu(xy,n,x,offx,incx,y,offy,incy)

  complex intent(out) :: xy
  fortranname wcdotu
  
  callstatement (*f2py_func)(&xy,&n,x+offx,&incx,y+offy,&incy)
  callprotoargument complex_float*,int*,complex_float*,int*,complex_float*,int*

  complex dimension(*),intent(in) :: x
  complex dimension(*),intent(in) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) &
       :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine cdotu

subroutine zdotu(xy,n,x,offx,incx,y,offy,incy)

  double complex intent(out) :: xy
  fortranname wzdotu
  
  callstatement (*f2py_func)(&xy,&n,x+offx,&incx,y+offy,&incy)
  callprotoargument complex_double*,int*,complex_double*,int*,complex_double*,int*

  double complex dimension(*),intent(in) :: x
  double complex dimension(*),intent(in) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) &
       :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine zdotu



subroutine cdotc(xy,n,x,offx,incx,y,offy,incy)

  complex intent (out) :: xy
  fortranname wcdotc

  callstatement (*f2py_func)(&xy,&n,x+offx,&incx,y+offy,&incy)
  callprotoargument complex_float*,int*,complex_float*,int*,complex_float*,int*

  complex dimension(*),intent(in) :: x
  complex dimension(*),intent(in) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine cdotc


subroutine zdotc(xy,n,x,offx,incx,y,offy,incy)

  double complex intent (out) :: xy
  fortranname wzdotc

  callstatement (*f2py_func)(&xy,&n,x+offx,&incx,y+offy,&incy)
  callprotoargument complex_double*,int*,complex_double*,int*,complex_double*,int*

  double complex dimension(*),intent(in) :: x
  double complex dimension(*),intent(in) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine zdotc



! <prefix3=s,d,sc,dz>
function snrm2(n,x,offx,incx) result(n2)

  real snrm2, n2

  callstatement (*f2py_func)(&snrm2, &n,x+offx,&incx)
  callprotoargument float*,int*,float*,int*

  real dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function snrm2

function dnrm2(n,x,offx,incx) result(n2)

  double precision dnrm2, n2

  callstatement (*f2py_func)(&dnrm2, &n,x+offx,&incx)
  callprotoargument double*,int*,double*,int*

  double precision dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function dnrm2

function scnrm2(n,x,offx,incx) result(n2)

  real scnrm2, n2

  callstatement (*f2py_func)(&scnrm2, &n,x+offx,&incx)
  callprotoargument float*,int*,complex_float*,int*

  complex dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function scnrm2

function dznrm2(n,x,offx,incx) result(n2)

  double precision dznrm2, n2

  callstatement (*f2py_func)(&dznrm2, &n,x+offx,&incx)
  callprotoargument double*,int*,complex_double*,int*

  double complex dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function dznrm2



function sasum(n,x,offx,incx) result (s)

  real sasum,s

  callstatement (*f2py_func)(&sasum,&n,x+offx,&incx)
  callprotoargument float*,int*,float*,int*

  real dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function sasum


function dasum(n,x,offx,incx) result (s)

  double precision dasum,s

  callstatement (*f2py_func)(&dasum,&n,x+offx,&incx)
  callprotoargument double*,int*,double*,int*

  double precision dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function dasum


function scasum(n,x,offx,incx) result (s)

  real scasum,s

  callstatement (*f2py_func)(&scasum,&n,x+offx,&incx)
  callprotoargument float*,int*,complex_float*,int*

  complex dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function scasum


function dzasum(n,x,offx,incx) result (s)

  double precision dzasum,s

  callstatement (*f2py_func)(&dzasum,&n,x+offx,&incx)
  callprotoargument double*,int*,complex_double*,int*

  double complex dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function dzasum



function isamax(n,x,offx,incx) result(k)

  ! This is to avoid Fortran wrappers.
  integer isamax,k
  fortranname F_FUNC(isamax,ISAMAX)
  intent(c) isamax

  callstatement isamax_return_value = (*f2py_func)(&n,x+offx,&incx) - 1
  callprotoargument int*,float*,int*

  real dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function isamax


function idamax(n,x,offx,incx) result(k)

  ! This is to avoid Fortran wrappers.
  integer idamax,k
  fortranname F_FUNC(idamax,IDAMAX)
  intent(c) idamax

  callstatement idamax_return_value = (*f2py_func)(&n,x+offx,&incx) - 1
  callprotoargument int*,double*,int*

  double precision dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function idamax


function icamax(n,x,offx,incx) result(k)

  ! This is to avoid Fortran wrappers.
  integer icamax,k
  fortranname F_FUNC(icamax,ICAMAX)
  intent(c) icamax

  callstatement icamax_return_value = (*f2py_func)(&n,x+offx,&incx) - 1
  callprotoargument int*,complex_float*,int*

  complex dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function icamax


function izamax(n,x,offx,incx) result(k)

  ! This is to avoid Fortran wrappers.
  integer izamax,k
  fortranname F_FUNC(izamax,IZAMAX)
  intent(c) izamax

  callstatement izamax_return_value = (*f2py_func)(&n,x+offx,&incx) - 1
  callprotoargument int*,complex_double*,int*

  double complex dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function izamax



! -*- f90 -*-
! Signatures for f2py-wrappers of FORTRAN LEVEL 2 BLAS functions.
!
! Author: Pearu Peterson
! Created: Jan-Feb 2002
!
! gemv, hemv, symv, trmv, ger, geru, gerc
!
! Not implemented:
!   gbmv, hbmv, hpmv, sbmv, spmv, tbmv, tpmv, trsv, tbsv, tpsv,
!   her, hpr, her2, hpr2, syr, spr, syr2, spr2
!
!XXX: make beta and y optional in hemv,symv similarly to gemv

subroutine sgemv(m,n,alpha,a,x,beta,y,offx,incx,offy,incy,trans,rows,cols,ly)
  ! y = gemv(alpha,a,x,beta=0,y=0,offx=0,incx=1,offy=0,incy=0,trans=0)
  ! Calculate y <- alpha * op(A) * x + beta * y

  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&alpha,a,&m,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,float*,float*,int*,float*,int*,float*,float*,int*

  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  real intent(in) :: alpha
  real intent(in),optional :: beta = 0.0

  real dimension(*),intent(in) :: x
  real dimension(ly),intent(in,copy,out),depend(ly),optional :: y
  integer intent(hide),depend(incy,rows,offy) :: ly = (y_capi==Py_None?1+offy+(rows-1)*abs(incy):-1)
  real dimension(m,n),intent(in) :: a
  integer depend(a),intent(hide):: m = shape(a,0)
  integer depend(a),intent(hide):: n = shape(a,1)

  integer optional,intent(in) :: offx=0
  integer optional,intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(cols-1)*abs(incx)) :: x
  depend(offx,cols,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(rows-1)*abs(incy)) :: y
  depend(offy,rows,incy) :: y

  integer depend(m,n,trans),intent(hide) :: rows = (trans?n:m)
  integer depend(m,n,trans),intent(hide) :: cols = (trans?m:n)

end subroutine sgemv


subroutine dgemv(m,n,alpha,a,x,beta,y,offx,incx,offy,incy,trans,rows,cols,ly)
  ! y = gemv(alpha,a,x,beta=0,y=0,offx=0,incx=1,offy=0,incy=0,trans=0)
  ! Calculate y <- alpha * op(A) * x + beta * y

  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&alpha,a,&m,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,double*,double*,int*,double*,int*,double*,double*,int*

  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  double precision intent(in) :: alpha
  double precision intent(in),optional :: beta = 0.0

  double precision dimension(*),intent(in) :: x
  double precision dimension(ly),intent(in,copy,out),depend(ly),optional :: y
  integer intent(hide),depend(incy,rows,offy) :: ly = (y_capi==Py_None?1+offy+(rows-1)*abs(incy):-1)
  double precision dimension(m,n),intent(in) :: a
  integer depend(a),intent(hide):: m = shape(a,0)
  integer depend(a),intent(hide):: n = shape(a,1)

  integer optional,intent(in) :: offx=0
  integer optional,intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(cols-1)*abs(incx)) :: x
  depend(offx,cols,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(rows-1)*abs(incy)) :: y
  depend(offy,rows,incy) :: y

  integer depend(m,n,trans),intent(hide) :: rows = (trans?n:m)
  integer depend(m,n,trans),intent(hide) :: cols = (trans?m:n)

end subroutine dgemv


subroutine cgemv(m,n,alpha,a,x,beta,y,offx,incx,offy,incy,trans,rows,cols,ly)
  ! y = gemv(alpha,a,x,beta=0,y=0,offx=0,incx=1,offy=0,incy=0,trans=0)
  ! Calculate y <- alpha * op(A) * x + beta * y

  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&alpha,a,&m,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,complex_float*,complex_float*,int*,complex_float*,int*,complex_float*,complex_float*,int*

  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(*),intent(in) :: x
  complex dimension(ly),intent(in,copy,out),depend(ly),optional :: y
  integer intent(hide),depend(incy,rows,offy) :: ly = (y_capi==Py_None?1+offy+(rows-1)*abs(incy):-1)
  complex dimension(m,n),intent(in) :: a
  integer depend(a),intent(hide):: m = shape(a,0)
  integer depend(a),intent(hide):: n = shape(a,1)

  integer optional,intent(in) :: offx=0
  integer optional,intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(cols-1)*abs(incx)) :: x
  depend(offx,cols,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(rows-1)*abs(incy)) :: y
  depend(offy,rows,incy) :: y

  integer depend(m,n,trans),intent(hide) :: rows = (trans?n:m)
  integer depend(m,n,trans),intent(hide) :: cols = (trans?m:n)

end subroutine cgemv


subroutine zgemv(m,n,alpha,a,x,beta,y,offx,incx,offy,incy,trans,rows,cols,ly)
  ! y = gemv(alpha,a,x,beta=0,y=0,offx=0,incx=1,offy=0,incy=0,trans=0)
  ! Calculate y <- alpha * op(A) * x + beta * y

  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&alpha,a,&m,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,complex_double*,complex_double*,int*,complex_double*,int*,complex_double*,complex_double*,int*

  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(*),intent(in) :: x
  double complex dimension(ly),intent(in,copy,out),depend(ly),optional :: y
  integer intent(hide),depend(incy,rows,offy) :: ly = (y_capi==Py_None?1+offy+(rows-1)*abs(incy):-1)
  double complex dimension(m,n),intent(in) :: a
  integer depend(a),intent(hide):: m = shape(a,0)
  integer depend(a),intent(hide):: n = shape(a,1)

  integer optional,intent(in) :: offx=0
  integer optional,intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(cols-1)*abs(incx)) :: x
  depend(offx,cols,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(rows-1)*abs(incy)) :: y
  depend(offy,rows,incy) :: y

  integer depend(m,n,trans),intent(hide) :: rows = (trans?n:m)
  integer depend(m,n,trans),intent(hide) :: cols = (trans?m:n)

end subroutine zgemv



subroutine ssymv(n,alpha,a,x,beta,y,offx,incx,offy,incy,lower,ly)
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric/hermitian

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,a,&n,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,float*,float*,int*,float*,int*,float*,float*,int*

  integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  real intent(in) :: alpha
  real intent(in),optional :: beta = 0.0

  real dimension(*),intent(in) :: x
  real dimension(ly),intent(in,copy,out),depend(ly),optional :: y
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  real dimension(n,n),intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a),intent(hide):: n = shape(a,0)

  integer optional,intent(in) :: offx=0
  integer optional,intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

end subroutine  ssymv


subroutine dsymv(n,alpha,a,x,beta,y,offx,incx,offy,incy,lower,ly)
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric/hermitian

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,a,&n,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,double*,double*,int*,double*,int*,double*,double*,int*

  integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  double precision intent(in) :: alpha
  double precision intent(in),optional :: beta = 0.0

  double precision dimension(*),intent(in) :: x
  double precision dimension(ly),intent(in,copy,out),depend(ly),optional :: y
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  double precision dimension(n,n),intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a),intent(hide):: n = shape(a,0)

  integer optional,intent(in) :: offx=0
  integer optional,intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

end subroutine  dsymv


subroutine chemv(n,alpha,a,x,beta,y,offx,incx,offy,incy,lower,ly)
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric/hermitian

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,a,&n,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,complex_float*,complex_float*,int*,complex_float*,int*,complex_float*,complex_float*,int*

  integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(*),intent(in) :: x
  complex dimension(ly),intent(in,copy,out),depend(ly),optional :: y
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  complex dimension(n,n),intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a),intent(hide):: n = shape(a,0)

  integer optional,intent(in) :: offx=0
  integer optional,intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

end subroutine  chemv


subroutine zhemv(n,alpha,a,x,beta,y,offx,incx,offy,incy,lower,ly)
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric/hermitian

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,a,&n,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,complex_double*,complex_double*,int*,complex_double*,int*,complex_double*,complex_double*,int*

  integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(*),intent(in) :: x
  double complex dimension(ly),intent(in,copy,out),depend(ly),optional :: y
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  double complex dimension(n,n),intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a),intent(hide):: n = shape(a,0)

  integer optional,intent(in) :: offx=0
  integer optional,intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

end subroutine  zhemv



subroutine strmv(n,a,x,offx,incx,lower,trans,unitdiag)
  ! Calculate x <- op(A) * x, A is triangular

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,a,&n,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,float*,int*,float*,int*

  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
  integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  real dimension(*),intent(in,out,copy) :: x
  real dimension(n,n),intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a),intent(hide):: n = shape(a,0)

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  check(len(x)>offx+(n-1)*abs(incx)) :: n
  depend(x,offx,incx) :: n

end subroutine strmv


subroutine dtrmv(n,a,x,offx,incx,lower,trans,unitdiag)
  ! Calculate x <- op(A) * x, A is triangular

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,a,&n,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,double*,int*,double*,int*

  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
  integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  double precision dimension(*),intent(in,out,copy) :: x
  double precision dimension(n,n),intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a),intent(hide):: n = shape(a,0)

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  check(len(x)>offx+(n-1)*abs(incx)) :: n
  depend(x,offx,incx) :: n

end subroutine dtrmv


subroutine ctrmv(n,a,x,offx,incx,lower,trans,unitdiag)
  ! Calculate x <- op(A) * x, A is triangular

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,a,&n,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,complex_float*,int*,complex_float*,int*

  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
  integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  complex dimension(*),intent(in,out,copy) :: x
  complex dimension(n,n),intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a),intent(hide):: n = shape(a,0)

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  check(len(x)>offx+(n-1)*abs(incx)) :: n
  depend(x,offx,incx) :: n

end subroutine ctrmv


subroutine ztrmv(n,a,x,offx,incx,lower,trans,unitdiag)
  ! Calculate x <- op(A) * x, A is triangular

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,a,&n,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,complex_double*,int*,complex_double*,int*

  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
  integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  double complex dimension(*),intent(in,out,copy) :: x
  double complex dimension(n,n),intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a),intent(hide):: n = shape(a,0)

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  check(len(x)>offx+(n-1)*abs(incx)) :: n
  depend(x,offx,incx) :: n

end subroutine ztrmv



! <ftype6=real,double precision,complex,double complex,\2,\3>
subroutine sger(m,n,alpha,x,incx,y,incy,a,lda)
! a = ger(alpha,x,y,incx=1,incy=1,a=0,overwrite_x=1,overwrite_y=1,overwrite_a=0)
! Calculate a <- alpha*x*y^T + a
! Calculate a <- alpha*x*y^H + a
    integer intent(hide),depend(x) :: m = len(x)
    integer intent(hide),depend(y) :: n = len(y)
    real intent(in) :: alpha
    real dimension(m),intent(in,overwrite) :: x
    integer optional,intent(in),check(incx==1||incx==-1) :: incx = 1
    real dimension(n),intent(in,overwrite) :: y
    integer optional,intent(in),check(incy==1||incy==-1) :: incy = 1
    real dimension(m,n),intent(in,out,copy),optional :: a = 0.0
    integer intent(hide), depend(m) :: lda=m
end subroutine sger

subroutine dger(m,n,alpha,x,incx,y,incy,a,lda)
! a = ger(alpha,x,y,incx=1,incy=1,a=0,overwrite_x=1,overwrite_y=1,overwrite_a=0)
! Calculate a <- alpha*x*y^T + a
! Calculate a <- alpha*x*y^H + a
    integer intent(hide),depend(x) :: m = len(x)
    integer intent(hide),depend(y) :: n = len(y)
    double precision intent(in) :: alpha
    double precision dimension(m),intent(in,overwrite) :: x
    integer optional,intent(in),check(incx==1||incx==-1) :: incx = 1
    double precision dimension(n),intent(in,overwrite) :: y
    integer optional,intent(in),check(incy==1||incy==-1) :: incy = 1
    double precision dimension(m,n),intent(in,out,copy),optional :: a = 0.0
    integer intent(hide), depend(m) :: lda=m
end subroutine dger

subroutine cgeru(m,n,alpha,x,incx,y,incy,a,lda)
! a = ger(alpha,x,y,incx=1,incy=1,a=0,overwrite_x=1,overwrite_y=1,overwrite_a=0)
! Calculate a <- alpha*x*y^T + a
! Calculate a <- alpha*x*y^H + a
    integer intent(hide),depend(x) :: m = len(x)
    integer intent(hide),depend(y) :: n = len(y)
    complex intent(in) :: alpha
    complex dimension(m),intent(in,overwrite) :: x
    integer optional,intent(in),check(incx==1||incx==-1) :: incx = 1
    complex dimension(n),intent(in,overwrite) :: y
    integer optional,intent(in),check(incy==1||incy==-1) :: incy = 1
    complex dimension(m,n),intent(in,out,copy),optional :: a = (0.0,0.0)
    integer intent(hide), depend(m) :: lda=m
end subroutine cgeru

subroutine zgeru(m,n,alpha,x,incx,y,incy,a,lda)
! a = ger(alpha,x,y,incx=1,incy=1,a=0,overwrite_x=1,overwrite_y=1,overwrite_a=0)
! Calculate a <- alpha*x*y^T + a
! Calculate a <- alpha*x*y^H + a
    integer intent(hide),depend(x) :: m = len(x)
    integer intent(hide),depend(y) :: n = len(y)
    double complex intent(in) :: alpha
    double complex dimension(m),intent(in,overwrite) :: x
    integer optional,intent(in),check(incx==1||incx==-1) :: incx = 1
    double complex dimension(n),intent(in,overwrite) :: y
    integer optional,intent(in),check(incy==1||incy==-1) :: incy = 1
    double complex dimension(m,n),intent(in,out,copy),optional :: a = (0.0,0.0)
    integer intent(hide), depend(m) :: lda=m
end subroutine zgeru

subroutine cgerc(m,n,alpha,x,incx,y,incy,a,lda)
! a = ger(alpha,x,y,incx=1,incy=1,a=0,overwrite_x=1,overwrite_y=1,overwrite_a=0)
! Calculate a <- alpha*x*y^T + a
! Calculate a <- alpha*x*y^H + a
    integer intent(hide),depend(x) :: m = len(x)
    integer intent(hide),depend(y) :: n = len(y)
    complex intent(in) :: alpha
    complex dimension(m),intent(in,overwrite) :: x
    integer optional,intent(in),check(incx==1||incx==-1) :: incx = 1
    complex dimension(n),intent(in,overwrite) :: y
    integer optional,intent(in),check(incy==1||incy==-1) :: incy = 1
    complex dimension(m,n),intent(in,out,copy),optional :: a = (0.0,0.0)
    integer intent(hide), depend(m) :: lda=m
end subroutine cgerc

subroutine zgerc(m,n,alpha,x,incx,y,incy,a,lda)
! a = ger(alpha,x,y,incx=1,incy=1,a=0,overwrite_x=1,overwrite_y=1,overwrite_a=0)
! Calculate a <- alpha*x*y^T + a
! Calculate a <- alpha*x*y^H + a
    integer intent(hide),depend(x) :: m = len(x)
    integer intent(hide),depend(y) :: n = len(y)
    double complex intent(in) :: alpha
    double complex dimension(m),intent(in,overwrite) :: x
    integer optional,intent(in),check(incx==1||incx==-1) :: incx = 1
    double complex dimension(n),intent(in,overwrite) :: y
    integer optional,intent(in),check(incy==1||incy==-1) :: incy = 1
    double complex dimension(m,n),intent(in,out,copy),optional :: a = (0.0,0.0)
    integer intent(hide), depend(m) :: lda=m
end subroutine zgerc



! -*- f90 -*-
! Signatures for f2py-wrappers of FORTRAN LEVEL 3 BLAS functions.
!
! Author: Pearu Peterson
! Created: April 2002
!
!   gemm
!
! Not Implemented:
!   symm, hemm, syrk, herk, syr2k, her2k, trmm, trsm
!

subroutine sgemm(m,n,k,alpha,a,b,beta,c,trans_a,trans_b,lda,ka,ldb,kb)
  ! c = gemm(alpha,a,b,beta=0,c=0,trans_a=0,trans_b=0,overwrite_c=0)
  ! Calculate C <- alpha * op(A) * op(B) + beta * C

  callstatement (*f2py_func)((trans_a?(trans_a==2?"C":"T"):"N"),(trans_b?(trans_b==2?"C":"T"):"N"),&m,&n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,int*,float*,float*,int*,float*,int*,float*,float*,int*

  integer optional,intent(in),check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional,intent(in),check(trans_b>=0 && trans_b <=2) :: trans_b = 0
  real intent(in) :: alpha
  real intent(in),optional :: beta = 0.0

  real dimension(lda,ka),intent(in) :: a
  real dimension(ldb,kb),intent(in) :: b
  real dimension(m,n),intent(in,out,copy),depend(m,n),optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a,trans_a,ka,lda),intent(hide):: m = (trans_a?ka:lda)
  integer depend(a,trans_a,ka,lda),intent(hide):: k = (trans_a?lda:ka)
  integer depend(b,trans_b,kb,ldb,k),intent(hide),check(trans_b?kb==k:ldb==k):: n = (trans_b?ldb:kb)


end subroutine sgemm


subroutine dgemm(m,n,k,alpha,a,b,beta,c,trans_a,trans_b,lda,ka,ldb,kb)
  ! c = gemm(alpha,a,b,beta=0,c=0,trans_a=0,trans_b=0,overwrite_c=0)
  ! Calculate C <- alpha * op(A) * op(B) + beta * C

  callstatement (*f2py_func)((trans_a?(trans_a==2?"C":"T"):"N"),(trans_b?(trans_b==2?"C":"T"):"N"),&m,&n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,int*,double*,double*,int*,double*,int*,double*,double*,int*

  integer optional,intent(in),check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional,intent(in),check(trans_b>=0 && trans_b <=2) :: trans_b = 0
  double precision intent(in) :: alpha
  double precision intent(in),optional :: beta = 0.0

  double precision dimension(lda,ka),intent(in) :: a
  double precision dimension(ldb,kb),intent(in) :: b
  double precision dimension(m,n),intent(in,out,copy),depend(m,n),optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a,trans_a,ka,lda),intent(hide):: m = (trans_a?ka:lda)
  integer depend(a,trans_a,ka,lda),intent(hide):: k = (trans_a?lda:ka)
  integer depend(b,trans_b,kb,ldb,k),intent(hide),check(trans_b?kb==k:ldb==k):: n = (trans_b?ldb:kb)


end subroutine dgemm


subroutine cgemm(m,n,k,alpha,a,b,beta,c,trans_a,trans_b,lda,ka,ldb,kb)
  ! c = gemm(alpha,a,b,beta=0,c=0,trans_a=0,trans_b=0,overwrite_c=0)
  ! Calculate C <- alpha * op(A) * op(B) + beta * C

  callstatement (*f2py_func)((trans_a?(trans_a==2?"C":"T"):"N"),(trans_b?(trans_b==2?"C":"T"):"N"),&m,&n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,int*,complex_float*,complex_float*,int*,complex_float*,int*,complex_float*,complex_float*,int*

  integer optional,intent(in),check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional,intent(in),check(trans_b>=0 && trans_b <=2) :: trans_b = 0
  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(lda,ka),intent(in) :: a
  complex dimension(ldb,kb),intent(in) :: b
  complex dimension(m,n),intent(in,out,copy),depend(m,n),optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a,trans_a,ka,lda),intent(hide):: m = (trans_a?ka:lda)
  integer depend(a,trans_a,ka,lda),intent(hide):: k = (trans_a?lda:ka)
  integer depend(b,trans_b,kb,ldb,k),intent(hide),check(trans_b?kb==k:ldb==k):: n = (trans_b?ldb:kb)


end subroutine cgemm


subroutine zgemm(m,n,k,alpha,a,b,beta,c,trans_a,trans_b,lda,ka,ldb,kb)
  ! c = gemm(alpha,a,b,beta=0,c=0,trans_a=0,trans_b=0,overwrite_c=0)
  ! Calculate C <- alpha * op(A) * op(B) + beta * C

  callstatement (*f2py_func)((trans_a?(trans_a==2?"C":"T"):"N"),(trans_b?(trans_b==2?"C":"T"):"N"),&m,&n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,int*,complex_double*,complex_double*,int*,complex_double*,int*,complex_double*,complex_double*,int*

  integer optional,intent(in),check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional,intent(in),check(trans_b>=0 && trans_b <=2) :: trans_b = 0
  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(lda,ka),intent(in) :: a
  double complex dimension(ldb,kb),intent(in) :: b
  double complex dimension(m,n),intent(in,out,copy),depend(m,n),optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a,trans_a,ka,lda),intent(hide):: m = (trans_a?ka:lda)
  integer depend(a,trans_a,ka,lda),intent(hide):: k = (trans_a?lda:ka)
  integer depend(b,trans_b,kb,ldb,k),intent(hide),check(trans_b?kb==k:ldb==k):: n = (trans_b?ldb:kb)


end subroutine zgemm



    end interface
end python module fblas

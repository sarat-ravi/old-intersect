/* File: _fftpackmodule.c
 * This file is auto-generated with f2py (version:2).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * See http://cens.ioc.ee/projects/f2py2e/
 * Generation date: Thu Sep  6 15:26:17 2012
 * $Revision:$
 * $Date:$
 * Do not edit this file directly unless you know what you are doing!!!
 */
#ifdef __cplusplus
extern "C" {
#endif

/*********************** See f2py2e/cfuncs.py: includes ***********************/
#include "Python.h"
#include <stdarg.h>
#include "fortranobject.h"
#include <math.h>

/**************** See f2py2e/rules.py: mod_rules['modulebody'] ****************/
static PyObject *_fftpack_error;
static PyObject *_fftpack_module;

/*********************** See f2py2e/cfuncs.py: typedefs ***********************/
typedef struct {double r,i;} complex_double;
typedef struct {float r,i;} complex_float;

/****************** See f2py2e/cfuncs.py: typedefs_generated ******************/
/*need_typedefs_generated*/

/********************** See f2py2e/cfuncs.py: cppmacros **********************/
#define rank(var) var ## _Rank
#define shape(var,dim) var ## _Dims[dim]
#define old_rank(var) (((PyArrayObject *)(capi_ ## var ## _tmp))->nd)
#define old_shape(var,dim) (((PyArrayObject *)(capi_ ## var ## _tmp))->dimensions[dim])
#define fshape(var,dim) shape(var,rank(var)-dim-1)
#define len(var) shape(var,0)
#define flen(var) fshape(var,0)
#define old_size(var) PyArray_SIZE((PyArrayObject *)(capi_ ## var ## _tmp))
/* #define index(i) capi_i ## i */
#define slen(var) capi_ ## var ## _len
#define size(var, ...) f2py_size((PyArrayObject *)(capi_ ## var ## _tmp), ## __VA_ARGS__, -1)

#define CHECKSCALAR(check,tcheck,name,show,var)\
  if (!(check)) {\
    char errstring[256];\
    sprintf(errstring, "%s: "show, "("tcheck") failed for "name, var);\
    PyErr_SetString(_fftpack_error,errstring);\
    /*goto capi_fail;*/\
  } else 
#ifdef DEBUGCFUNCS
#define CFUNCSMESS(mess) fprintf(stderr,"debug-capi:"mess);
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) \
  PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
  fprintf(stderr,"\n");
#else
#define CFUNCSMESS(mess)
#define CFUNCSMESSPY(mess,obj)
#endif

#ifndef max
#define max(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a < b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b) ((a < b) ? (a) : (b))
#endif

#define CHECKARRAY(check,tcheck,name) \
  if (!(check)) {\
    PyErr_SetString(_fftpack_error,"("tcheck") failed for "name);\
    /*goto capi_fail;*/\
  } else 
#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F
#else
#define F_FUNC(f,F) _##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F##_
#else
#define F_FUNC(f,F) _##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F
#else
#define F_FUNC(f,F) f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F##_
#else
#define F_FUNC(f,F) f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_)
#else
#define F_FUNC_US(f,F) F_FUNC(f,F)
#endif


/************************ See f2py2e/cfuncs.py: cfuncs ************************/
int f2py_size(PyArrayObject* var, ...)
{
  npy_int sz = 0;
  npy_int dim;
  npy_int rank;
  va_list argp;
  va_start(argp, var);
  dim = va_arg(argp, npy_int);
  if (dim==-1)
    {
      sz = PyArray_SIZE(var);
    }
  else
    {
      rank = PyArray_NDIM(var);
      if (dim>=1 && dim<=rank)
        sz = PyArray_DIM(var, dim-1);
      else
        fprintf(stderr, "f2py_size: 2nd argument value=%d fails to satisfy 1<=value<=%d. Result will be 0.\n", dim, rank);
    }
  va_end(argp);
  return sz;
}

static int int_from_pyobj(int* v,PyObject *obj,const char *errmess) {
  PyObject* tmp = NULL;
  if (PyInt_Check(obj)) {
    *v = (int)PyInt_AS_LONG(obj);
    return 1;
  }
  tmp = PyNumber_Int(obj);
  if (tmp) {
    *v = PyInt_AS_LONG(tmp);
    Py_DECREF(tmp);
    return 1;
  }
  if (PyComplex_Check(obj))
    tmp = PyObject_GetAttrString(obj,"real");
  else if (PyString_Check(obj) || PyUnicode_Check(obj))
    /*pass*/;
  else if (PySequence_Check(obj))
    tmp = PySequence_GetItem(obj,0);
  if (tmp) {
    PyErr_Clear();
    if (int_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
    Py_DECREF(tmp);
  }
  {
    PyObject* err = PyErr_Occurred();
    if (err==NULL) err = _fftpack_error;
    PyErr_SetString(err,errmess);
  }
  return 0;
}

static struct { int nd;npy_intp *d;int *i,*i_tr,tr; } forcombcache;
static int initforcomb(npy_intp *dims,int nd,int tr) {
  int k;
  if (dims==NULL) return 0;
  if (nd<0) return 0;
  forcombcache.nd = nd;
  forcombcache.d = dims;
  forcombcache.tr = tr;
  if ((forcombcache.i = (int *)malloc(sizeof(int)*nd))==NULL) return 0;
  if ((forcombcache.i_tr = (int *)malloc(sizeof(int)*nd))==NULL) return 0;
  for (k=1;k<nd;k++) {
    forcombcache.i[k] = forcombcache.i_tr[nd-k-1] = 0;
  }
  forcombcache.i[0] = forcombcache.i_tr[nd-1] = -1;
  return 1;
}
static int *nextforcomb(void) {
  int j,*i,*i_tr,k;
  int nd=forcombcache.nd;
  if ((i=forcombcache.i) == NULL) return NULL;
  if ((i_tr=forcombcache.i_tr) == NULL) return NULL;
  if (forcombcache.d == NULL) return NULL;
  i[0]++;
  if (i[0]==forcombcache.d[0]) {
    j=1;
    while ((j<nd) && (i[j]==forcombcache.d[j]-1)) j++;
    if (j==nd) {
      free(i);
      free(i_tr);
      return NULL;
    }
    for (k=0;k<j;k++) i[k] = i_tr[nd-k-1] = 0;
    i[j]++;
    i_tr[nd-j-1]++;
  } else
    i_tr[nd-1]++;
  if (forcombcache.tr) return i_tr;
  return i;
}

/********************* See f2py2e/cfuncs.py: userincludes *********************/
/*need_userincludes*/

/********************* See f2py2e/capi_rules.py: usercode *********************/


/* See f2py2e/rules.py */
extern void zfft(complex_double*,int,int,int,int);
extern void drfft(double*,int,int,int,int);
extern void zrfft(complex_double*,int,int,int,int);
extern void zfftnd(complex_double*,int,int*,int,int,int);
extern void destroy_zfft_cache(void);
extern void destroy_zfftnd_cache(void);
extern void destroy_drfft_cache(void);
extern void cfft(complex_float*,int,int,int,int);
extern void rfft(float*,int,int,int,int);
extern void crfft(complex_float*,int,int,int,int);
extern void cfftnd(complex_float*,int,int*,int,int,int);
extern void destroy_cfft_cache(void);
extern void destroy_cfftnd_cache(void);
extern void destroy_rfft_cache(void);
extern void ddct1(double*,int,int,int);
extern void ddct2(double*,int,int,int);
extern void ddct3(double*,int,int,int);
extern void dct1(float*,int,int,int);
extern void dct2(float*,int,int,int);
extern void dct3(float*,int,int,int);
extern void destroy_ddct2_cache(void);
extern void destroy_ddct1_cache(void);
extern void destroy_dct2_cache(void);
extern void destroy_dct1_cache(void);
/*eof externroutines*/

/******************** See f2py2e/capi_rules.py: usercode1 ********************/


/******************* See f2py2e/cb_rules.py: buildcallback *******************/
/*need_callbacks*/

/*********************** See f2py2e/rules.py: buildapi ***********************/

/************************************ zfft ************************************/
static char doc_f2py_rout__fftpack_zfft[] = "\
Function signature:\n\
  y = zfft(x,[n,direction,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('D') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 0 input int\n"
"  n := size(x) input int\n"
"  direction := 1 input int\n"
"  normalize := (direction<0) input int\n"
"Return objects:\n"
"  y : rank-1 array('D') with bounds (*) and x storage";
/* extern void zfft(complex_double*,int,int,int,int); */
static PyObject *f2py_rout__fftpack_zfft(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(complex_double*,int,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  complex_double *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 0;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int direction = 0;
  PyObject *direction_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  static char *capi_kwlist[] = {"x","n","direction","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOOi:_fftpack.zfft",\
    capi_kwlist,&x_capi,&n_capi,&direction_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable direction */
  if (direction_capi == Py_None) direction = 1; else
    f2py_success = int_from_pyobj(&direction,direction_capi,"_fftpack.zfft() 2nd keyword (direction) can't be converted to int");
  if (f2py_success) {
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_CDOUBLE,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.zfft to C/Fortran array" );
  } else {
    x = (complex_double *)(capi_x_tmp->data);

  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = (direction<0); else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.zfft() 3rd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n */
  if (n_capi == Py_None) n = size(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_fftpack.zfft() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(n>0,"n>0","1st keyword n","zfft:n=%d",n) {
  /* Processing variable howmany */
  howmany = size(x)/n;
  CHECKSCALAR(n*howmany==size(x),"n*howmany==size(x)","hidden howmany","zfft:howmany=%d",howmany) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,n,direction,howmany,normalize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(n*howmany==size(x))*/
  /* End of cleaning variable howmany */
  } /*CHECKSCALAR(n>0)*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  } /*if (f2py_success) of direction*/
  /* End of cleaning variable direction */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of zfft ********************************/

/*********************************** drfft ***********************************/
static char doc_f2py_rout__fftpack_drfft[] = "\
Function signature:\n\
  y = drfft(x,[n,direction,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('d') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 0 input int\n"
"  n := size(x) input int\n"
"  direction := 1 input int\n"
"  normalize := (direction<0) input int\n"
"Return objects:\n"
"  y : rank-1 array('d') with bounds (*) and x storage";
/* extern void drfft(double*,int,int,int,int); */
static PyObject *f2py_rout__fftpack_drfft(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 0;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int direction = 0;
  PyObject *direction_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  static char *capi_kwlist[] = {"x","n","direction","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOOi:_fftpack.drfft",\
    capi_kwlist,&x_capi,&n_capi,&direction_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable direction */
  if (direction_capi == Py_None) direction = 1; else
    f2py_success = int_from_pyobj(&direction,direction_capi,"_fftpack.drfft() 2nd keyword (direction) can't be converted to int");
  if (f2py_success) {
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_DOUBLE,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.drfft to C/Fortran array" );
  } else {
    x = (double *)(capi_x_tmp->data);

  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = (direction<0); else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.drfft() 3rd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n */
  if (n_capi == Py_None) n = size(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_fftpack.drfft() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(n>0&&n<=size(x),"n>0&&n<=size(x)","1st keyword n","drfft:n=%d",n) {
  /* Processing variable howmany */
  howmany = size(x)/n;
  CHECKSCALAR(n*howmany==size(x),"n*howmany==size(x)","hidden howmany","drfft:howmany=%d",howmany) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,n,direction,howmany,normalize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(n*howmany==size(x))*/
  /* End of cleaning variable howmany */
  } /*CHECKSCALAR(n>0&&n<=size(x))*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  } /*if (f2py_success) of direction*/
  /* End of cleaning variable direction */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of drfft ********************************/

/*********************************** zrfft ***********************************/
static char doc_f2py_rout__fftpack_zrfft[] = "\
Function signature:\n\
  y = zrfft(x,[n,direction,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('D') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 1 input int\n"
"  n := size(x) input int\n"
"  direction := 1 input int\n"
"  normalize := (direction<0) input int\n"
"Return objects:\n"
"  y : rank-1 array('D') with bounds (*) and x storage";
/* extern void zrfft(complex_double*,int,int,int,int); */
static PyObject *f2py_rout__fftpack_zrfft(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(complex_double*,int,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  complex_double *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 1;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int direction = 0;
  PyObject *direction_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  static char *capi_kwlist[] = {"x","n","direction","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOOi:_fftpack.zrfft",\
    capi_kwlist,&x_capi,&n_capi,&direction_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable direction */
  if (direction_capi == Py_None) direction = 1; else
    f2py_success = int_from_pyobj(&direction,direction_capi,"_fftpack.zrfft() 2nd keyword (direction) can't be converted to int");
  if (f2py_success) {
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_CDOUBLE,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.zrfft to C/Fortran array" );
  } else {
    x = (complex_double *)(capi_x_tmp->data);

  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = (direction<0); else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.zrfft() 3rd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n */
  if (n_capi == Py_None) n = size(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_fftpack.zrfft() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(n>0&&n<=size(x),"n>0&&n<=size(x)","1st keyword n","zrfft:n=%d",n) {
  /* Processing variable howmany */
  howmany = size(x)/n;
  CHECKSCALAR(n*howmany==size(x),"n*howmany==size(x)","hidden howmany","zrfft:howmany=%d",howmany) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,n,direction,howmany,normalize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(n*howmany==size(x))*/
  /* End of cleaning variable howmany */
  } /*CHECKSCALAR(n>0&&n<=size(x))*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  } /*if (f2py_success) of direction*/
  /* End of cleaning variable direction */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of zrfft ********************************/

/*********************************** zfftnd ***********************************/
static char doc_f2py_rout__fftpack_zfftnd[] = "\
Function signature:\n\
  y = zfftnd(x,[s,direction,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('D') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 0 input int\n"
"  s := old_shape(x,j++) input rank-1 array('i') with bounds (r)\n"
"  direction := 1 input int\n"
"  normalize := (direction<0) input int\n"
"Return objects:\n"
"  y : rank-1 array('D') with bounds (*) and x storage";
/* extern void zfftnd(complex_double*,int,int*,int,int,int); */
static PyObject *f2py_rout__fftpack_zfftnd(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(complex_double*,int,int*,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  complex_double *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 0;
  PyObject *x_capi = Py_None;
  int r = 0;
  int *s = NULL;
  npy_intp s_Dims[1] = {-1};
  const int s_Rank = 1;
  PyArrayObject *capi_s_tmp = NULL;
  int capi_s_intent = 0;
  PyObject *s_capi = Py_None;
  int direction = 0;
  PyObject *direction_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  int j = 0;
  static char *capi_kwlist[] = {"x","s","direction","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOOi:_fftpack.zfftnd",\
    capi_kwlist,&x_capi,&s_capi,&direction_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable direction */
  if (direction_capi == Py_None) direction = 1; else
    f2py_success = int_from_pyobj(&direction,direction_capi,"_fftpack.zfftnd() 2nd keyword (direction) can't be converted to int");
  if (f2py_success) {
  /* Processing variable howmany */
  howmany = 1;
  /* Processing variable j */
  j = 0;
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_CDOUBLE,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.zfftnd to C/Fortran array" );
  } else {
    x = (complex_double *)(capi_x_tmp->data);

  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = (direction<0); else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.zfftnd() 3rd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable r */
  r = old_rank(x);
  /* Processing variable s */
  s_Dims[0]=r;
  capi_s_intent |= F2PY_INTENT_IN|F2PY_INTENT_C|F2PY_OPTIONAL;
  capi_s_tmp = array_from_pyobj(PyArray_INT,s_Dims,s_Rank,capi_s_intent,s_capi);
  if (capi_s_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st keyword `s' of _fftpack.zfftnd to C/Fortran array" );
  } else {
    s = (int *)(capi_s_tmp->data);

  if (s_capi == Py_None) {


    int *_i,capi_i=0;
    CFUNCSMESS("zfftnd: Initializing s=old_shape(x,j++)\n");
    if (initforcomb(capi_s_tmp->dimensions,capi_s_tmp->nd,1)) {
      while ((_i = nextforcomb()))
        s[capi_i++] = old_shape(x,j++); /* fortran way */
    } else {
      if (!PyErr_Occurred())
        PyErr_SetString(_fftpack_error,"Initialization of 1st keyword s failed (initforcomb).");
      f2py_success = 0;
    }
  }
  if (f2py_success) {
  CHECKARRAY(r>=len(s),"r>=len(s)","1st keyword s") {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        {              int i,sz=1,xsz=size(x);               for (i=0;i<r;++i) sz *= s[i];               howmany = xsz/sz;               if (sz*howmany==xsz)                 (*f2py_func)(x,r,s,direction,howmany,normalize);               else {                f2py_success = 0;                 PyErr_SetString(_fftpack_error,                   "inconsistency in x.shape and s argument");                 }               };
        /*(*f2py_func)(x,r,s,direction,howmany,normalize,j);*/
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKARRAY(r>=len(s))*/
  }  /*if (f2py_success) of s init*/
  if((PyObject *)capi_s_tmp!=s_capi) {
    Py_XDECREF(capi_s_tmp); }
  }  /*if (capi_s_tmp == NULL) ... else of s*/
  /* End of cleaning variable s */
  /* End of cleaning variable r */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  /* End of cleaning variable j */
  /* End of cleaning variable howmany */
  } /*if (f2py_success) of direction*/
  /* End of cleaning variable direction */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of zfftnd *******************************/

/***************************** destroy_zfft_cache *****************************/
static char doc_f2py_rout__fftpack_destroy_zfft_cache[] = "\
Function signature:\n\
  destroy_zfft_cache()\n\
";
/* extern void destroy_zfft_cache(void); */
static PyObject *f2py_rout__fftpack_destroy_zfft_cache(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":_fftpack.destroy_zfft_cache",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of destroy_zfft_cache *************************/

/**************************** destroy_zfftnd_cache ****************************/
static char doc_f2py_rout__fftpack_destroy_zfftnd_cache[] = "\
Function signature:\n\
  destroy_zfftnd_cache()\n\
";
/* extern void destroy_zfftnd_cache(void); */
static PyObject *f2py_rout__fftpack_destroy_zfftnd_cache(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":_fftpack.destroy_zfftnd_cache",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of destroy_zfftnd_cache ************************/

/**************************** destroy_drfft_cache ****************************/
static char doc_f2py_rout__fftpack_destroy_drfft_cache[] = "\
Function signature:\n\
  destroy_drfft_cache()\n\
";
/* extern void destroy_drfft_cache(void); */
static PyObject *f2py_rout__fftpack_destroy_drfft_cache(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":_fftpack.destroy_drfft_cache",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of destroy_drfft_cache *************************/

/************************************ cfft ************************************/
static char doc_f2py_rout__fftpack_cfft[] = "\
Function signature:\n\
  y = cfft(x,[n,direction,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('F') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 0 input int\n"
"  n := size(x) input int\n"
"  direction := 1 input int\n"
"  normalize := (direction<0) input int\n"
"Return objects:\n"
"  y : rank-1 array('F') with bounds (*) and x storage";
/* extern void cfft(complex_float*,int,int,int,int); */
static PyObject *f2py_rout__fftpack_cfft(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(complex_float*,int,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  complex_float *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 0;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int direction = 0;
  PyObject *direction_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  static char *capi_kwlist[] = {"x","n","direction","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOOi:_fftpack.cfft",\
    capi_kwlist,&x_capi,&n_capi,&direction_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable direction */
  if (direction_capi == Py_None) direction = 1; else
    f2py_success = int_from_pyobj(&direction,direction_capi,"_fftpack.cfft() 2nd keyword (direction) can't be converted to int");
  if (f2py_success) {
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_CFLOAT,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.cfft to C/Fortran array" );
  } else {
    x = (complex_float *)(capi_x_tmp->data);

  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = (direction<0); else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.cfft() 3rd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n */
  if (n_capi == Py_None) n = size(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_fftpack.cfft() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(n>0,"n>0","1st keyword n","cfft:n=%d",n) {
  /* Processing variable howmany */
  howmany = size(x)/n;
  CHECKSCALAR(n*howmany==size(x),"n*howmany==size(x)","hidden howmany","cfft:howmany=%d",howmany) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,n,direction,howmany,normalize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(n*howmany==size(x))*/
  /* End of cleaning variable howmany */
  } /*CHECKSCALAR(n>0)*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  } /*if (f2py_success) of direction*/
  /* End of cleaning variable direction */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of cfft ********************************/

/************************************ rfft ************************************/
static char doc_f2py_rout__fftpack_rfft[] = "\
Function signature:\n\
  y = rfft(x,[n,direction,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('f') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 0 input int\n"
"  n := size(x) input int\n"
"  direction := 1 input int\n"
"  normalize := (direction<0) input int\n"
"Return objects:\n"
"  y : rank-1 array('f') with bounds (*) and x storage";
/* extern void rfft(float*,int,int,int,int); */
static PyObject *f2py_rout__fftpack_rfft(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,int,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 0;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int direction = 0;
  PyObject *direction_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  static char *capi_kwlist[] = {"x","n","direction","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOOi:_fftpack.rfft",\
    capi_kwlist,&x_capi,&n_capi,&direction_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable direction */
  if (direction_capi == Py_None) direction = 1; else
    f2py_success = int_from_pyobj(&direction,direction_capi,"_fftpack.rfft() 2nd keyword (direction) can't be converted to int");
  if (f2py_success) {
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_FLOAT,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.rfft to C/Fortran array" );
  } else {
    x = (float *)(capi_x_tmp->data);

  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = (direction<0); else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.rfft() 3rd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n */
  if (n_capi == Py_None) n = size(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_fftpack.rfft() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(n>0&&n<=size(x),"n>0&&n<=size(x)","1st keyword n","rfft:n=%d",n) {
  /* Processing variable howmany */
  howmany = size(x)/n;
  CHECKSCALAR(n*howmany==size(x),"n*howmany==size(x)","hidden howmany","rfft:howmany=%d",howmany) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,n,direction,howmany,normalize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(n*howmany==size(x))*/
  /* End of cleaning variable howmany */
  } /*CHECKSCALAR(n>0&&n<=size(x))*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  } /*if (f2py_success) of direction*/
  /* End of cleaning variable direction */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of rfft ********************************/

/*********************************** crfft ***********************************/
static char doc_f2py_rout__fftpack_crfft[] = "\
Function signature:\n\
  y = crfft(x,[n,direction,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('F') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 1 input int\n"
"  n := size(x) input int\n"
"  direction := 1 input int\n"
"  normalize := (direction<0) input int\n"
"Return objects:\n"
"  y : rank-1 array('F') with bounds (*) and x storage";
/* extern void crfft(complex_float*,int,int,int,int); */
static PyObject *f2py_rout__fftpack_crfft(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(complex_float*,int,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  complex_float *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 1;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int direction = 0;
  PyObject *direction_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  static char *capi_kwlist[] = {"x","n","direction","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOOi:_fftpack.crfft",\
    capi_kwlist,&x_capi,&n_capi,&direction_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable direction */
  if (direction_capi == Py_None) direction = 1; else
    f2py_success = int_from_pyobj(&direction,direction_capi,"_fftpack.crfft() 2nd keyword (direction) can't be converted to int");
  if (f2py_success) {
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_CFLOAT,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.crfft to C/Fortran array" );
  } else {
    x = (complex_float *)(capi_x_tmp->data);

  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = (direction<0); else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.crfft() 3rd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n */
  if (n_capi == Py_None) n = size(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_fftpack.crfft() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(n>0&&n<=size(x),"n>0&&n<=size(x)","1st keyword n","crfft:n=%d",n) {
  /* Processing variable howmany */
  howmany = size(x)/n;
  CHECKSCALAR(n*howmany==size(x),"n*howmany==size(x)","hidden howmany","crfft:howmany=%d",howmany) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,n,direction,howmany,normalize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(n*howmany==size(x))*/
  /* End of cleaning variable howmany */
  } /*CHECKSCALAR(n>0&&n<=size(x))*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  } /*if (f2py_success) of direction*/
  /* End of cleaning variable direction */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of crfft ********************************/

/*********************************** cfftnd ***********************************/
static char doc_f2py_rout__fftpack_cfftnd[] = "\
Function signature:\n\
  y = cfftnd(x,[s,direction,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('F') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 0 input int\n"
"  s := old_shape(x,j++) input rank-1 array('i') with bounds (r)\n"
"  direction := 1 input int\n"
"  normalize := (direction<0) input int\n"
"Return objects:\n"
"  y : rank-1 array('F') with bounds (*) and x storage";
/* extern void cfftnd(complex_float*,int,int*,int,int,int); */
static PyObject *f2py_rout__fftpack_cfftnd(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(complex_float*,int,int*,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  complex_float *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 0;
  PyObject *x_capi = Py_None;
  int r = 0;
  int *s = NULL;
  npy_intp s_Dims[1] = {-1};
  const int s_Rank = 1;
  PyArrayObject *capi_s_tmp = NULL;
  int capi_s_intent = 0;
  PyObject *s_capi = Py_None;
  int direction = 0;
  PyObject *direction_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  int j = 0;
  static char *capi_kwlist[] = {"x","s","direction","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOOi:_fftpack.cfftnd",\
    capi_kwlist,&x_capi,&s_capi,&direction_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable direction */
  if (direction_capi == Py_None) direction = 1; else
    f2py_success = int_from_pyobj(&direction,direction_capi,"_fftpack.cfftnd() 2nd keyword (direction) can't be converted to int");
  if (f2py_success) {
  /* Processing variable howmany */
  howmany = 1;
  /* Processing variable j */
  j = 0;
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_CFLOAT,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.cfftnd to C/Fortran array" );
  } else {
    x = (complex_float *)(capi_x_tmp->data);

  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = (direction<0); else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.cfftnd() 3rd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable r */
  r = old_rank(x);
  /* Processing variable s */
  s_Dims[0]=r;
  capi_s_intent |= F2PY_INTENT_IN|F2PY_INTENT_C|F2PY_OPTIONAL;
  capi_s_tmp = array_from_pyobj(PyArray_INT,s_Dims,s_Rank,capi_s_intent,s_capi);
  if (capi_s_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st keyword `s' of _fftpack.cfftnd to C/Fortran array" );
  } else {
    s = (int *)(capi_s_tmp->data);

  if (s_capi == Py_None) {


    int *_i,capi_i=0;
    CFUNCSMESS("cfftnd: Initializing s=old_shape(x,j++)\n");
    if (initforcomb(capi_s_tmp->dimensions,capi_s_tmp->nd,1)) {
      while ((_i = nextforcomb()))
        s[capi_i++] = old_shape(x,j++); /* fortran way */
    } else {
      if (!PyErr_Occurred())
        PyErr_SetString(_fftpack_error,"Initialization of 1st keyword s failed (initforcomb).");
      f2py_success = 0;
    }
  }
  if (f2py_success) {
  CHECKARRAY(r>=len(s),"r>=len(s)","1st keyword s") {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        {              int i,sz=1,xsz=size(x);               for (i=0;i<r;++i) sz *= s[i];               howmany = xsz/sz;               if (sz*howmany==xsz)                 (*f2py_func)(x,r,s,direction,howmany,normalize);               else {                f2py_success = 0;                 PyErr_SetString(_fftpack_error,                   "inconsistency in x.shape and s argument");                 }               };
        /*(*f2py_func)(x,r,s,direction,howmany,normalize,j);*/
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKARRAY(r>=len(s))*/
  }  /*if (f2py_success) of s init*/
  if((PyObject *)capi_s_tmp!=s_capi) {
    Py_XDECREF(capi_s_tmp); }
  }  /*if (capi_s_tmp == NULL) ... else of s*/
  /* End of cleaning variable s */
  /* End of cleaning variable r */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  /* End of cleaning variable j */
  /* End of cleaning variable howmany */
  } /*if (f2py_success) of direction*/
  /* End of cleaning variable direction */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of cfftnd *******************************/

/***************************** destroy_cfft_cache *****************************/
static char doc_f2py_rout__fftpack_destroy_cfft_cache[] = "\
Function signature:\n\
  destroy_cfft_cache()\n\
";
/* extern void destroy_cfft_cache(void); */
static PyObject *f2py_rout__fftpack_destroy_cfft_cache(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":_fftpack.destroy_cfft_cache",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of destroy_cfft_cache *************************/

/**************************** destroy_cfftnd_cache ****************************/
static char doc_f2py_rout__fftpack_destroy_cfftnd_cache[] = "\
Function signature:\n\
  destroy_cfftnd_cache()\n\
";
/* extern void destroy_cfftnd_cache(void); */
static PyObject *f2py_rout__fftpack_destroy_cfftnd_cache(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":_fftpack.destroy_cfftnd_cache",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of destroy_cfftnd_cache ************************/

/***************************** destroy_rfft_cache *****************************/
static char doc_f2py_rout__fftpack_destroy_rfft_cache[] = "\
Function signature:\n\
  destroy_rfft_cache()\n\
";
/* extern void destroy_rfft_cache(void); */
static PyObject *f2py_rout__fftpack_destroy_rfft_cache(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":_fftpack.destroy_rfft_cache",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of destroy_rfft_cache *************************/

/*********************************** ddct1 ***********************************/
static char doc_f2py_rout__fftpack_ddct1[] = "\
Function signature:\n\
  y = ddct1(x,[n,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('d') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 0 input int\n"
"  n := size(x) input int\n"
"  normalize := 0 input int\n"
"Return objects:\n"
"  y : rank-1 array('d') with bounds (*) and x storage";
/* extern void ddct1(double*,int,int,int); */
static PyObject *f2py_rout__fftpack_ddct1(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 0;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  static char *capi_kwlist[] = {"x","n","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOi:_fftpack.ddct1",\
    capi_kwlist,&x_capi,&n_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = 0; else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.ddct1() 2nd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_DOUBLE,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.ddct1 to C/Fortran array" );
  } else {
    x = (double *)(capi_x_tmp->data);

  /* Processing variable n */
  if (n_capi == Py_None) n = size(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_fftpack.ddct1() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(n>0&&n<=size(x),"n>0&&n<=size(x)","1st keyword n","ddct1:n=%d",n) {
  /* Processing variable howmany */
  howmany = size(x)/n;
  CHECKSCALAR(n*howmany==size(x),"n*howmany==size(x)","hidden howmany","ddct1:howmany=%d",howmany) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,n,howmany,normalize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(n*howmany==size(x))*/
  /* End of cleaning variable howmany */
  } /*CHECKSCALAR(n>0&&n<=size(x))*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of ddct1 ********************************/

/*********************************** ddct2 ***********************************/
static char doc_f2py_rout__fftpack_ddct2[] = "\
Function signature:\n\
  y = ddct2(x,[n,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('d') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 0 input int\n"
"  n := size(x) input int\n"
"  normalize := 0 input int\n"
"Return objects:\n"
"  y : rank-1 array('d') with bounds (*) and x storage";
/* extern void ddct2(double*,int,int,int); */
static PyObject *f2py_rout__fftpack_ddct2(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 0;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  static char *capi_kwlist[] = {"x","n","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOi:_fftpack.ddct2",\
    capi_kwlist,&x_capi,&n_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_DOUBLE,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.ddct2 to C/Fortran array" );
  } else {
    x = (double *)(capi_x_tmp->data);

  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = 0; else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.ddct2() 2nd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n */
  if (n_capi == Py_None) n = size(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_fftpack.ddct2() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(n>0&&n<=size(x),"n>0&&n<=size(x)","1st keyword n","ddct2:n=%d",n) {
  /* Processing variable howmany */
  howmany = size(x)/n;
  CHECKSCALAR(n*howmany==size(x),"n*howmany==size(x)","hidden howmany","ddct2:howmany=%d",howmany) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,n,howmany,normalize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(n*howmany==size(x))*/
  /* End of cleaning variable howmany */
  } /*CHECKSCALAR(n>0&&n<=size(x))*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of ddct2 ********************************/

/*********************************** ddct3 ***********************************/
static char doc_f2py_rout__fftpack_ddct3[] = "\
Function signature:\n\
  y = ddct3(x,[n,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('d') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 0 input int\n"
"  n := size(x) input int\n"
"  normalize := 0 input int\n"
"Return objects:\n"
"  y : rank-1 array('d') with bounds (*) and x storage";
/* extern void ddct3(double*,int,int,int); */
static PyObject *f2py_rout__fftpack_ddct3(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 0;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  static char *capi_kwlist[] = {"x","n","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOi:_fftpack.ddct3",\
    capi_kwlist,&x_capi,&n_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = 0; else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.ddct3() 2nd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_DOUBLE,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.ddct3 to C/Fortran array" );
  } else {
    x = (double *)(capi_x_tmp->data);

  /* Processing variable n */
  if (n_capi == Py_None) n = size(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_fftpack.ddct3() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(n>0&&n<=size(x),"n>0&&n<=size(x)","1st keyword n","ddct3:n=%d",n) {
  /* Processing variable howmany */
  howmany = size(x)/n;
  CHECKSCALAR(n*howmany==size(x),"n*howmany==size(x)","hidden howmany","ddct3:howmany=%d",howmany) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,n,howmany,normalize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(n*howmany==size(x))*/
  /* End of cleaning variable howmany */
  } /*CHECKSCALAR(n>0&&n<=size(x))*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of ddct3 ********************************/

/************************************ dct1 ************************************/
static char doc_f2py_rout__fftpack_dct1[] = "\
Function signature:\n\
  y = dct1(x,[n,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('f') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 0 input int\n"
"  n := size(x) input int\n"
"  normalize := 0 input int\n"
"Return objects:\n"
"  y : rank-1 array('f') with bounds (*) and x storage";
/* extern void dct1(float*,int,int,int); */
static PyObject *f2py_rout__fftpack_dct1(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 0;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  static char *capi_kwlist[] = {"x","n","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOi:_fftpack.dct1",\
    capi_kwlist,&x_capi,&n_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = 0; else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.dct1() 2nd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_FLOAT,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.dct1 to C/Fortran array" );
  } else {
    x = (float *)(capi_x_tmp->data);

  /* Processing variable n */
  if (n_capi == Py_None) n = size(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_fftpack.dct1() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(n>0&&n<=size(x),"n>0&&n<=size(x)","1st keyword n","dct1:n=%d",n) {
  /* Processing variable howmany */
  howmany = size(x)/n;
  CHECKSCALAR(n*howmany==size(x),"n*howmany==size(x)","hidden howmany","dct1:howmany=%d",howmany) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,n,howmany,normalize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(n*howmany==size(x))*/
  /* End of cleaning variable howmany */
  } /*CHECKSCALAR(n>0&&n<=size(x))*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of dct1 ********************************/

/************************************ dct2 ************************************/
static char doc_f2py_rout__fftpack_dct2[] = "\
Function signature:\n\
  y = dct2(x,[n,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('f') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 0 input int\n"
"  n := size(x) input int\n"
"  normalize := 0 input int\n"
"Return objects:\n"
"  y : rank-1 array('f') with bounds (*) and x storage";
/* extern void dct2(float*,int,int,int); */
static PyObject *f2py_rout__fftpack_dct2(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 0;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  static char *capi_kwlist[] = {"x","n","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOi:_fftpack.dct2",\
    capi_kwlist,&x_capi,&n_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = 0; else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.dct2() 2nd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_FLOAT,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.dct2 to C/Fortran array" );
  } else {
    x = (float *)(capi_x_tmp->data);

  /* Processing variable n */
  if (n_capi == Py_None) n = size(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_fftpack.dct2() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(n>0&&n<=size(x),"n>0&&n<=size(x)","1st keyword n","dct2:n=%d",n) {
  /* Processing variable howmany */
  howmany = size(x)/n;
  CHECKSCALAR(n*howmany==size(x),"n*howmany==size(x)","hidden howmany","dct2:howmany=%d",howmany) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,n,howmany,normalize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(n*howmany==size(x))*/
  /* End of cleaning variable howmany */
  } /*CHECKSCALAR(n>0&&n<=size(x))*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of dct2 ********************************/

/************************************ dct3 ************************************/
static char doc_f2py_rout__fftpack_dct3[] = "\
Function signature:\n\
  y = dct3(x,[n,normalize,overwrite_x])\n\
Required arguments:\n"
"  x : input rank-1 array('f') with bounds (*)\n"
"Optional arguments:\n"
"  overwrite_x := 0 input int\n"
"  n := size(x) input int\n"
"  normalize := 0 input int\n"
"Return objects:\n"
"  y : rank-1 array('f') with bounds (*) and x storage";
/* extern void dct3(float*,int,int,int); */
static PyObject *f2py_rout__fftpack_dct3(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,int,int,int)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  int capi_overwrite_x = 0;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int howmany = 0;
  int normalize = 0;
  PyObject *normalize_capi = Py_None;
  static char *capi_kwlist[] = {"x","n","normalize","overwrite_x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OOi:_fftpack.dct3",\
    capi_kwlist,&x_capi,&n_capi,&normalize_capi,&capi_overwrite_x))
    return NULL;
/*frompyobj*/
  /* Processing variable normalize */
  if (normalize_capi == Py_None) normalize = 0; else
    f2py_success = int_from_pyobj(&normalize,normalize_capi,"_fftpack.dct3() 2nd keyword (normalize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable x */
  capi_x_intent |= (capi_overwrite_x?0:F2PY_INTENT_COPY);
  ;
  capi_x_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT|F2PY_INTENT_C;
  capi_x_tmp = array_from_pyobj(PyArray_FLOAT,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(_fftpack_error,"failed in converting 1st argument `x' of _fftpack.dct3 to C/Fortran array" );
  } else {
    x = (float *)(capi_x_tmp->data);

  /* Processing variable n */
  if (n_capi == Py_None) n = size(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_fftpack.dct3() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(n>0&&n<=size(x),"n>0&&n<=size(x)","1st keyword n","dct3:n=%d",n) {
  /* Processing variable howmany */
  howmany = size(x)/n;
  CHECKSCALAR(n*howmany==size(x),"n*howmany==size(x)","hidden howmany","dct3:howmany=%d",howmany) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,n,howmany,normalize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_x_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(n*howmany==size(x))*/
  /* End of cleaning variable howmany */
  } /*CHECKSCALAR(n>0&&n<=size(x))*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
  } /*if (f2py_success) of normalize*/
  /* End of cleaning variable normalize */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of dct3 ********************************/

/**************************** destroy_ddct2_cache ****************************/
static char doc_f2py_rout__fftpack_destroy_ddct2_cache[] = "\
Function signature:\n\
  destroy_ddct2_cache()\n\
";
/* extern void destroy_ddct2_cache(void); */
static PyObject *f2py_rout__fftpack_destroy_ddct2_cache(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":_fftpack.destroy_ddct2_cache",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of destroy_ddct2_cache *************************/

/**************************** destroy_ddct1_cache ****************************/
static char doc_f2py_rout__fftpack_destroy_ddct1_cache[] = "\
Function signature:\n\
  destroy_ddct1_cache()\n\
";
/* extern void destroy_ddct1_cache(void); */
static PyObject *f2py_rout__fftpack_destroy_ddct1_cache(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":_fftpack.destroy_ddct1_cache",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of destroy_ddct1_cache *************************/

/***************************** destroy_dct2_cache *****************************/
static char doc_f2py_rout__fftpack_destroy_dct2_cache[] = "\
Function signature:\n\
  destroy_dct2_cache()\n\
";
/* extern void destroy_dct2_cache(void); */
static PyObject *f2py_rout__fftpack_destroy_dct2_cache(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":_fftpack.destroy_dct2_cache",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of destroy_dct2_cache *************************/

/***************************** destroy_dct1_cache *****************************/
static char doc_f2py_rout__fftpack_destroy_dct1_cache[] = "\
Function signature:\n\
  destroy_dct1_cache()\n\
";
/* extern void destroy_dct1_cache(void); */
static PyObject *f2py_rout__fftpack_destroy_dct1_cache(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":_fftpack.destroy_dct1_cache",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of destroy_dct1_cache *************************/
/*eof body*/

/******************* See f2py2e/f90mod_rules.py: buildhooks *******************/
/*need_f90modhooks*/

/************** See f2py2e/rules.py: module_rules['modulebody'] **************/

/******************* See f2py2e/common_rules.py: buildhooks *******************/

/*need_commonhooks*/

/**************************** See f2py2e/rules.py ****************************/

static FortranDataDef f2py_routine_defs[] = {
  {"zfft",-1,{{-1}},0,(char *)zfft,(f2py_init_func)f2py_rout__fftpack_zfft,doc_f2py_rout__fftpack_zfft},
  {"drfft",-1,{{-1}},0,(char *)drfft,(f2py_init_func)f2py_rout__fftpack_drfft,doc_f2py_rout__fftpack_drfft},
  {"zrfft",-1,{{-1}},0,(char *)zrfft,(f2py_init_func)f2py_rout__fftpack_zrfft,doc_f2py_rout__fftpack_zrfft},
  {"zfftnd",-1,{{-1}},0,(char *)zfftnd,(f2py_init_func)f2py_rout__fftpack_zfftnd,doc_f2py_rout__fftpack_zfftnd},
  {"destroy_zfft_cache",-1,{{-1}},0,(char *)destroy_zfft_cache,(f2py_init_func)f2py_rout__fftpack_destroy_zfft_cache,doc_f2py_rout__fftpack_destroy_zfft_cache},
  {"destroy_zfftnd_cache",-1,{{-1}},0,(char *)destroy_zfftnd_cache,(f2py_init_func)f2py_rout__fftpack_destroy_zfftnd_cache,doc_f2py_rout__fftpack_destroy_zfftnd_cache},
  {"destroy_drfft_cache",-1,{{-1}},0,(char *)destroy_drfft_cache,(f2py_init_func)f2py_rout__fftpack_destroy_drfft_cache,doc_f2py_rout__fftpack_destroy_drfft_cache},
  {"cfft",-1,{{-1}},0,(char *)cfft,(f2py_init_func)f2py_rout__fftpack_cfft,doc_f2py_rout__fftpack_cfft},
  {"rfft",-1,{{-1}},0,(char *)rfft,(f2py_init_func)f2py_rout__fftpack_rfft,doc_f2py_rout__fftpack_rfft},
  {"crfft",-1,{{-1}},0,(char *)crfft,(f2py_init_func)f2py_rout__fftpack_crfft,doc_f2py_rout__fftpack_crfft},
  {"cfftnd",-1,{{-1}},0,(char *)cfftnd,(f2py_init_func)f2py_rout__fftpack_cfftnd,doc_f2py_rout__fftpack_cfftnd},
  {"destroy_cfft_cache",-1,{{-1}},0,(char *)destroy_cfft_cache,(f2py_init_func)f2py_rout__fftpack_destroy_cfft_cache,doc_f2py_rout__fftpack_destroy_cfft_cache},
  {"destroy_cfftnd_cache",-1,{{-1}},0,(char *)destroy_cfftnd_cache,(f2py_init_func)f2py_rout__fftpack_destroy_cfftnd_cache,doc_f2py_rout__fftpack_destroy_cfftnd_cache},
  {"destroy_rfft_cache",-1,{{-1}},0,(char *)destroy_rfft_cache,(f2py_init_func)f2py_rout__fftpack_destroy_rfft_cache,doc_f2py_rout__fftpack_destroy_rfft_cache},
  {"ddct1",-1,{{-1}},0,(char *)ddct1,(f2py_init_func)f2py_rout__fftpack_ddct1,doc_f2py_rout__fftpack_ddct1},
  {"ddct2",-1,{{-1}},0,(char *)ddct2,(f2py_init_func)f2py_rout__fftpack_ddct2,doc_f2py_rout__fftpack_ddct2},
  {"ddct3",-1,{{-1}},0,(char *)ddct3,(f2py_init_func)f2py_rout__fftpack_ddct3,doc_f2py_rout__fftpack_ddct3},
  {"dct1",-1,{{-1}},0,(char *)dct1,(f2py_init_func)f2py_rout__fftpack_dct1,doc_f2py_rout__fftpack_dct1},
  {"dct2",-1,{{-1}},0,(char *)dct2,(f2py_init_func)f2py_rout__fftpack_dct2,doc_f2py_rout__fftpack_dct2},
  {"dct3",-1,{{-1}},0,(char *)dct3,(f2py_init_func)f2py_rout__fftpack_dct3,doc_f2py_rout__fftpack_dct3},
  {"destroy_ddct2_cache",-1,{{-1}},0,(char *)destroy_ddct2_cache,(f2py_init_func)f2py_rout__fftpack_destroy_ddct2_cache,doc_f2py_rout__fftpack_destroy_ddct2_cache},
  {"destroy_ddct1_cache",-1,{{-1}},0,(char *)destroy_ddct1_cache,(f2py_init_func)f2py_rout__fftpack_destroy_ddct1_cache,doc_f2py_rout__fftpack_destroy_ddct1_cache},
  {"destroy_dct2_cache",-1,{{-1}},0,(char *)destroy_dct2_cache,(f2py_init_func)f2py_rout__fftpack_destroy_dct2_cache,doc_f2py_rout__fftpack_destroy_dct2_cache},
  {"destroy_dct1_cache",-1,{{-1}},0,(char *)destroy_dct1_cache,(f2py_init_func)f2py_rout__fftpack_destroy_dct1_cache,doc_f2py_rout__fftpack_destroy_dct1_cache},

/*eof routine_defs*/
  {NULL}
};

static PyMethodDef f2py_module_methods[] = {

  {NULL,NULL}
};

#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef moduledef = {
  PyModuleDef_HEAD_INIT,
  "_fftpack",
  NULL,
  -1,
  f2py_module_methods,
  NULL,
  NULL,
  NULL,
  NULL
};
#endif

#if PY_VERSION_HEX >= 0x03000000
#define RETVAL m
PyObject *PyInit__fftpack(void) {
#else
#define RETVAL
PyMODINIT_FUNC init_fftpack(void) {
#endif
  int i;
  PyObject *m,*d, *s;
#if PY_VERSION_HEX >= 0x03000000
  m = _fftpack_module = PyModule_Create(&moduledef);
#else
  m = _fftpack_module = Py_InitModule("_fftpack", f2py_module_methods);
#endif
  Py_TYPE(&PyFortran_Type) = &PyType_Type;
  import_array();
  if (PyErr_Occurred())
    {PyErr_SetString(PyExc_ImportError, "can't initialize module _fftpack (failed to import numpy)"); return RETVAL;}
  d = PyModule_GetDict(m);
  s = PyString_FromString("$Revision: $");
  PyDict_SetItemString(d, "__version__", s);
#if PY_VERSION_HEX >= 0x03000000
  s = PyUnicode_FromString(
#else
  s = PyString_FromString(
#endif
    "This module '_fftpack' is auto-generated with f2py (version:2).\nFunctions:\n"
"  y = zfft(x,n=size(x),direction=1,normalize=(direction<0),overwrite_x=0)\n"
"  y = drfft(x,n=size(x),direction=1,normalize=(direction<0),overwrite_x=0)\n"
"  y = zrfft(x,n=size(x),direction=1,normalize=(direction<0),overwrite_x=1)\n"
"  y = zfftnd(x,s=old_shape(x,j++),direction=1,normalize=(direction<0),overwrite_x=0)\n"
"  destroy_zfft_cache()\n"
"  destroy_zfftnd_cache()\n"
"  destroy_drfft_cache()\n"
"  y = cfft(x,n=size(x),direction=1,normalize=(direction<0),overwrite_x=0)\n"
"  y = rfft(x,n=size(x),direction=1,normalize=(direction<0),overwrite_x=0)\n"
"  y = crfft(x,n=size(x),direction=1,normalize=(direction<0),overwrite_x=1)\n"
"  y = cfftnd(x,s=old_shape(x,j++),direction=1,normalize=(direction<0),overwrite_x=0)\n"
"  destroy_cfft_cache()\n"
"  destroy_cfftnd_cache()\n"
"  destroy_rfft_cache()\n"
"  y = ddct1(x,n=size(x),normalize=0,overwrite_x=0)\n"
"  y = ddct2(x,n=size(x),normalize=0,overwrite_x=0)\n"
"  y = ddct3(x,n=size(x),normalize=0,overwrite_x=0)\n"
"  y = dct1(x,n=size(x),normalize=0,overwrite_x=0)\n"
"  y = dct2(x,n=size(x),normalize=0,overwrite_x=0)\n"
"  y = dct3(x,n=size(x),normalize=0,overwrite_x=0)\n"
"  destroy_ddct2_cache()\n"
"  destroy_ddct1_cache()\n"
"  destroy_dct2_cache()\n"
"  destroy_dct1_cache()\n"
".");
  PyDict_SetItemString(d, "__doc__", s);
  _fftpack_error = PyErr_NewException ("_fftpack.error", NULL, NULL);
  Py_DECREF(s);
  for(i=0;f2py_routine_defs[i].name!=NULL;i++)
    PyDict_SetItemString(d, f2py_routine_defs[i].name,PyFortranObject_NewAsAttr(&f2py_routine_defs[i]));
























/*eof initf2pywraphooks*/
/*eof initf90modhooks*/

/*eof initcommonhooks*/


#ifdef F2PY_REPORT_ATEXIT
  if (! PyErr_Occurred())
    on_exit(f2py_report_on_exit,(void*)"_fftpack");
#endif

  return RETVAL;
}
#ifdef __cplusplus
}
#endif
